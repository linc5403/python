* Build-in object preview

| Object type                  | Example literals/creation                              |
| Numbers                      | 1234, 3.1415, 3+4j, 0b111, Decimal(), Fraction()       |
| Strings                      | 'spam', "Bob's", b'a\x01c', u'sp\xc4m'                 |
| Lists                        | [1, [2, 'three'], 4.5], list(range(10))                |
| Dictionaries                 | {'food': 'spam', 'taste': 'yum'}, dict(hours=10)       |
| Tuples                       | (1, 'spam', 4, 'U'), tuple('spam'), namedtuple         |
| Files                        | open('eggs.txt'), open(r'C:\ham.bin', 'wb')            |
| Sets                         | set('abc'), {'a', 'b', 'c'}                            |
| Other core types             | Booleans, types, None                                  |
| Program unit types           | Functions, modules, classes (Part IV, Part V, Part VI) |
| Implementation-related types | Compiled code, stack tracebacks (Part IV, Part VII)    |

* Immutability

 String都是不可变的, 无法改变其中的一个值, 只能构建一个新的字符串.

 Every object in Python is classified as either immutable (unchangeable) or not. In terms of the core types, numbers, strings, and tuples are immutable; lists, dictionaries, and sets are not—they can be changed in place freely, as can most new objects you’ll code with classes. 
  
 Python中的对象要么是不可变的(numbers, strings, tuples)

 要么是可变的(lists, sets, dictionaries)

* TODO bytearray

* 泛型操作和类型操作

  - 泛型操作通常是函数调用, 如 ~len(x)~
  - 类型操作通常是对象的方法调用, 如 ~s.upper()~

* TODO Pattern Matching

* List comprehension expression

  - ~[row[1] for row in M]~
  - ~[row[1] for row in M if row[1] % 2 != 0]~

* Dictionaries

* Iteration

  In a nutshell, an object is iterable if it is either a physically stored sequence in memory, or an object that generates one item at a time in the context of an iteration operation—a sort of “virtual” sequence. More formally, both types of objects are considered iterable because they support the iteration protocol—they respond to the iter call with an object that advances in response to next calls and raises an exception when finished producing values.

  支持迭代协议的对象都可以迭代-----iter() next()

* Tuples

  Functionally, they’re used to represent fixed collections of items: the components of a specific calendar date, for instance. Syntactically, they are normally coded in parentheses instead of square brackets, and they support arbitrary types, arbitrary nesting, and the usual sequence

** Why Tuples?
   
   So, why have a type that is like a list, but supports fewer operations? Frankly, tuples are not generally used as often as lists in practice, but their immutability is the whole point. If you pass a collection of objects around your program as a list, it can be changed anywhere; if you use a tuple, it cannot. That is, tuples provide a sort of integrity constraint that is convenient in programs larger than those we’ll write here. We’ll talk more about tuples later in the book, including an extension that builds upon them called named tuples. For now, though, let’s jump ahead to our last major core type: the file.

* Files

* Numeric Types

  - Integer and floating-point objects
  - Complex number objects
  - Decimal: fixed-precision objects
  - Fraction: rational number objects
  - Sets: collections with numeric operations
  - Booleans: true and false
  - Built-in functions and modules: round, math, random, etc.
  - Expressions; unlimited integer precision; bitwise operations; hex, octal, and binary formats
  - Third-party extensions: vectors, libraries, visualization, plotting, etc.

** Numeric Literals

*** Decimal Type
    #+begin_example
      In [5]: from decimal import Decimal

      In [6]: Decimal(0.1)
      Out[6]: Decimal('0.1000000000000000055511151231257827021181583404541015625')

      In [7]: Decimal(0.1) + Decimal(0.1) + Decimal(0.1)
      Out[7]: Decimal('0.3000000000000000166533453694')

      In [8]: Decimal(0.1) + Decimal(0.1) + Decimal(0.1) - Decimal(0.3)
      Out[8]: Decimal('2.775557561565156540423631668E-17')

      In [9]: Decimal('0.1') + Decimal('0.1') + Decimal('0.1') - Decimal('0.3')
      Out[9]: Decimal('0.0')
    #+end_example

    *可以用来表示经济, 钱*

    #+begin_example
      >>> 1999 + 1.33      # This has more digits in memory than displayed in 3.3
      2000.33
      >>>
      >>> decimal.getcontext().prec = 2
      >>> pay = decimal.Decimal(str(1999 + 1.33))
      >>> pay
      Decimal('2000.33')
    #+end_example

*** Fraction Type

** IMMUTABLE CONSTRAINTS AND FROZEN SETS

   Sets are powerful and flexible objects, but they do have one constraint in both 3.X and 2.X that you should keep in mind—largely because of their implementation, sets can only contain immutable (a.k.a. “hashable”) object types. Hence, lists and dictionaries cannot be embedded in sets, but tuples can if you need to store compound values. Tuples compare by their full values when used in set operations:

   Sets中只能放不可变的(hashable)对象, 所以list和dict是不能放到里面的.而可以将Tuple放到Set中

   #+begin_example
     >>> S
     {1.23}
     >>> S.add([1, 2, 3])                   # Only immutable objects work in a set
     TypeError: unhashable type: 'list'
     >>> S.add({'a':1})
     TypeError: unhashable type: 'dict'
     >>> S.add((1, 2, 3))
     >>> S                                  # No list or dict, but tuple OK
     {1.23, (1, 2, 3)}

     >>> S | {(4, 5, 6), (1, 2, 3)}         # Union: same as S.union(...)
     {1.23, (4, 5, 6), (1, 2, 3)}
     >>> (1, 2, 3) in S                     # Membership: by complete values
     True
     >>> (1, 4, 3) in S
     False
   #+end_example

   Sets themselves are mutable too, and so cannot be nested in other sets directly; if you need to store a set inside another set, the frozenset built-in call works just like set but creates an immutable set that cannot change and thus can be embedded in other sets.

   Sets自身是可变的, 因此也不能嵌套在其他Set中. 但是可以使用 ~frozenset()~ 方法将一个set对象固化

   #+begin_example
     In [12]: s = set()

     In [13]: s.add(1)

     In [14]: s.add(2)

     In [15]: s
     Out[15]: {1, 2}

     In [16]: ss = frozenset(s)

     In [17]: s.add(ss)

     In [18]: s
     Out[18]: {1, 2, frozenset({1, 2})}
   #+end_example

*** WHY SETS?
    1. 过滤重复项

       list->set->list

       #+begin_example
	 >>> L = [1, 2, 1, 3, 2, 4, 5]
	 >>> set(L)
	 {1, 2, 3, 4, 5}
	 >>> L = list(set(L))                                  # Remove duplicates
	 >>> L
	 [1, 2, 3, 4, 5]

	 >>> list(set(['yy', 'cc', 'aa', 'xx', 'dd', 'aa']))   # But order may change
	 ['cc', 'xx', 'yy', 'dd', 'aa']
       #+end_example

    2. 比较list, string等其他可迭代对象的不同
       
       set1 - set2
       
       #+begin_example
	 >>> set([1, 3, 5, 7]) - set([1, 2, 4, 5, 6])          # Find list differences
	 {3, 7}
	 >>> set('abcdefg') - set('abdghij')                   # Find string differences
	 {'c', 'e', 'f'}
	 >>> set('spam') - set(['h', 'a', 'm'])                # Find differences, mixed
	 {'p', 's'}

	 >>> set(dir(bytes)) - set(dir(bytearray))             # In bytes but not bytearray
	 {'__getnewargs__'}
	 >>> set(dir(bytearray)) - set(dir(bytes))
	 {'append', 'copy', '__alloc__', '__imul__', 'remove', 'pop', 'insert', ...more...]
       #+end_example

    3. 只关心collection的内容, 不关心顺序的时候用来比较是否相同

       #+begin_example
	 >>> L1, L2 = [1, 3, 5, 2, 4], [2, 5, 3, 4, 1]
]	 >>> L1 == L2                                          # Order matters in sequences
	 False
	 >>> set(L1) == set(L2)                                # Order-neutral equality
	 True
	 >>> sorted(L1) == sorted(L2)                          # Similar but results ordered
	 True
	 >>> 'spam' == 'asmp', set('spam') == set('asmp'), sorted('spam') == sorted('asmp')
	 (False, True, True)
       #+end_example

    4. 遍历图或循环结构是用于记录是否已经处理过当前节点

       Sets can also be used to keep track of where you’ve already been when traversing a graph or other cyclic structure. For example, the transitive module reloader and inheritance tree lister examples we’ll study in Chapter 25 and Chapter 31, respectively, must keep track of items visited to avoid loops, as Chapter 19 discusses in the abstract. Using a list in this context is inefficient because searches require linear scans. Although recording states visited as keys in a dictionary is efficient, sets offer an alternative that’s essentially equivalent (and may be more or less intuitive, depending on whom you ask).


    5. 用来处理大的数据集时∩和∪特别有用
       sets are also convenient when you’re dealing with large data sets (database query results, for example)—the intersection of two sets contains objects common to both categories, and the union contains all items in either set.

       #+begin_example
	 >>> engineers = {'bob', 'sue', 'ann', 'vic'}
	 >>> managers  = {'tom', 'sue'}

	 >>> 'bob' in engineers                   # Is bob an engineer?
	 True

	 >>> engineers & managers                 # Who is both engineer and manager?
	 {'sue'}

	 >>> engineers | managers                 # All people in either category
	 {'bob', 'tom', 'sue', 'vic', 'ann'}

	 >>> engineers - managers                 # Engineers who are not managers
	 {'vic', 'ann', 'bob'}

	 >>> managers - engineers                 # Managers who are not engineers
	 {'tom'}

	 >>> engineers > managers                 # Are all managers engineers? (superset)
	 False

	 >>> {'bob', 'sue'} < engineers           # Are both engineers? (subset)
	 True

	 >>> (managers | engineers) > managers    # All people is a superset of managers
	 True

	 >>> managers ^ engineers                 # Who is in one but not both?
	 {'tom', 'vic', 'ann', 'bob'}

	 >>> (managers | engineers) - (managers ^ engineers)     # Intersection!
	 {'sue'}
       #+end_example
** Booleans
   数值上是1和0, 但是是bool类的实例

   #+begin_example
     >>> type(True)
     <class 'bool'>
     >>> isinstance(True, int)
     True
     >>> True == 1                # Same value
     True
     >>> True is 1                # But a different object: see the next chapter
     False
     >>> True or False            # Same as: 1 or 0
     True
     >>> True + 4                 # (Hmmm)
     5
   #+end_example
* Dynamic Type(动态类型)

  [[file:./img/lp5e_0601.png]]
  
  变量和对象的关系:

  Names (a.k.a. variables) and objects after running the assignment a = 3. Variable a becomes a reference to the object 3. Internally, the variable is really a pointer to the object’s memory space created by running the literal expression 3.

  - Variables are entries in a system table, with spaces for links to objects.

  - Objects are pieces of allocated memory, with enough space to represent the values for which they stand.
    
  - References are automatically followed pointers from variables to objects.

  Technically speaking, objects have more structure than just enough space to represent their values. Each object also has two standard header fields: a type designator used to mark the type of the object, and a reference counter used to determine when it’s OK to reclaim the object. 

  技术上说, 对象不仅仅只包含values的空间, 至少还包含两个额外的东西: 类型指示符和引用计数器.

  *Types Live with Objects, Not Variables*

  *Objects Are Garbage-Collected*
** Shared References

   #+begin_example
     >>> a = 3
     >>> b = a
   #+end_example

   [[file:./img/lp5e_0602.png]]

   Names and objects after next running the assignment b = a. Variable b becomes a reference to the object 3. Internally, the variable is really a pointer to the object’s memory space created by running the literal expression 3.


   [[file:./img/lp5e_0603.png]]

    Names and objects after finally running the assignment a = ‘spam’. Variable a references the new object (i.e., piece of memory) created by running the literal expression ‘spam’, but variable b still refers to the original object 3. Because this assignment is not an in-place change to the object 3, it changes only variable a, not b.
** Shared References and In-Place Changes
   #+begin_src python
     import copy
     X = copy.copy(Y)          # Make top-level "shallow" copy of any object Y
     X = copy.deepcopy(Y)      # Make deep copy of any object Y: copy all nested parts
   #+end_src
** Shared References and Equality
   #+begin_src python
     >>> L = [1, 2, 3]
     >>> M = L                 # M and L reference the same object
     >>> L == M                # Same values
     True
     >>> L is M                # Same objects
     True
   #+end_src

   The first technique here, the *==* operator, tests whether the two referenced objects have the *same values*; this is the method almost always used for equality checks in Python. The second method, the is operator, instead tests for object identity—it returns True only if both names point to the exact same object, so it is a much stronger form of equality testing and is rarely applied in most programs.

   Really, *is* simply compares the pointers that implement references, and it serves as a way to detect shared references in your code if needed. It returns False if the names point to equivalent but different objects, as is the case when we run two different literal expressions:

   #+begin_src python
     >>> L = [1, 2, 3]
     >>> M = [1, 2, 3]         # M and L reference different objects
     >>> L == M                # Same values
     True
     >>> L is M                # Different objects
     False
   #+end_src

   #+begin_src python
     >>> X = 42
     >>> Y = 42                # Should be two different objects
     >>> X == Y
     True
     >>> X is Y                # Same object anyhow: caching at work!
     True
   #+end_src

   the ~getrefcount~ function in the standard sys module returns the object’s reference count. When I ask about the integer object 1 in the IDLE GUI, for instance, it reports 647 reuses of this same object (most of which are in IDLE’s system code, not mine, though this returns 173 outside IDLE so Python must be hoarding 1s as well):
** Dynamic Typing Is Everywhere
** “WEAK” REFERENCES
   You may occasionally see the term “weak reference” in the Python world. This is a somewhat advanced tool, but is related to the reference model we’ve explored here, and like the ~is~ operator, can’t really be understood without it.

   In short, a weak reference, implemented by the ~weakref~ standard library module, is a reference to an object that does not by itself prevent the referenced object from being garbage-collected. If the last remaining references to an object are weak references, the object is reclaimed and the weak references to it are automatically deleted (or otherwise notified).

   This can be useful in dictionary-based caches of large objects, for example; otherwise, the cache’s reference alone would keep the object in memory indefinitely. Still, this is really just a special-case extension to the reference model. For more details, see Python’s library manual.
* String Fundamentals
  *string* — an ordered collection of characters used to store and represent text- and bytes-based information. 
** Unicode: The Short Story
   In Python 3.X there are three string types: str is used for Unicode text (including ASCII), bytes is used for binary data (including encoded text), and bytearray is a mutable variant of bytes. Files work in two modes: text, which represents content as str and implements Unicode encodings, and binary, which deals in raw bytes and does no data translation.

   In fact, the primary distinction of Unicode often lies in the translation (a.k.a. encoding) step required to move it to and from files. Beyond that, it’s largely just string processing.

   Unicode主要在读取和写入文件的时候才需要考虑. 其他时候用String就可以了.
** String Basics
   Python’s strings serve the same role as character arrays in languages such as C, but they are a somewhat higher-level tool than arrays. Unlike in C, in Python, strings come with a powerful set of processing tools. Also unlike languages such as C, Python *has no distinct type for individual characters*; instead, you just use *one-character strings*

   Strictly speaking, Python strings are categorized as immutable sequences, meaning that the characters they contain have a left-to-right positional order and that they cannot be changed in place. In fact, strings are the first representative of the larger class of objects called sequences that we will study here. 

   严格的说, Strings属于不可变序列. 

** String Literals
   
*** Single- and Double-Quoted Strings Are the Same

*** Escape Sequences Represent Special Characters
    The character ~\~, and one or more characters following it in the string literal, are replaced with a single character in the resulting string object, which has the binary value specified by the escape sequence. 
    
    3.X defines str strings formally as sequences of *Unicode code points*, not bytes, to make this clear.

    | Escape    | Meaning                                         |
    | \newline  | Ignored (continuation line)                     |
    | \\        | Backslash (stores one \)                        |
    | \'        | Single quote (stores ')                         |
    | \"        | Double quote (stores ")                         |
    | \a        | Bell                                            |
    | \b        | Backspace                                       |
    | \f        | Formfeed                                        |
    | \n        | Newline (linefeed)                              |
    | \r        | Carriage return                                 |
    | \t        | Horizontal tab                                  |
    | \v        | Vertical tab                                    |
    | \xhh      | Character with hex value hh (exactly 2 digits)  |
    | \ooo      | Character with octal value ooo (up to 3 digits) |
    | \0        | Null: binary 0 character (doesn’t end string)   |
    | \N{ id }  | Unicode database ID                             |
    | \uhhhh    | Unicode character with 16-bit hex value         |
    | \Uhhhhhhh | Unicode character with 32-bit hex valuea        |
    | \other    | Not an escape (keeps both \ and other)          |

    #+begin_src python
      >>> s = 'a\0b\0c'
      >>> s
      'a\x00b\x00c'
      >>> len(s)
      5
    #+end_src

    In Python, a zero (null) character like this does not terminate a string the way a “null byte” typically does in C. Instead, Python keeps both the string’s length and text in memory. In fact, no character terminates a string in Python. Here’s a string that is all absolute binary escape codes—a binary 1 and 2 (coded in octal), followed by a binary 3 (coded in hexadecimal):
    #+begin_src python
      >>> s = '\001\002\x03'
      >>> s
      '\x01\x02\x03'
      >>> len(s)
      3
    #+end_src

*** Raw Strings Suppress Escapes

    #+begin_src python
      >>> path = r'C:\new\text.dat'
      >>> path                          # Show as Python code
      'C:\\new\\text.dat'
      >>> print(path)                   # User-friendly format
      C:\new\text.dat
      >>> len(path)                     # String length
      15
    #+end_src

    即使是Raw Strings也不能以 ~\~ 结束
    #+begin_src python
      In [32]: path = r'C:\new\text.dat\'
	File "<ipython-input-32-7d67db395ae9>", line 1
	  path = r'C:\new\text.dat\'
				    ^
      SyntaxError: EOL while scanning string literal
    #+end_src
    
    如果必须要以 ~\~ 结束, 那么有几个办法:
    
    1. truncate
       #+begin_src python
	 In [35]: path = r'C:\new\text.dat\\'[:-1]
       #+end_src

    2. join
       #+begin_src python
	 In [38]: path = r'C:\new\text.dat' + '\\'

	 In [39]: print(path)
	 C:\new\text.dat\
       #+end_src

    3. 不要使用r'...'

*** Triple Quotes Code Multiline Block Strings
    
** Strings in Action
   
*** Basic Operations

    - ~+~
    - ~*~
    - ~len()~
    - ~for c in s:~

*** Indexing and Slicing
    
    [[file:./img/lp5e_0701.png]]

    Offsets and slices: positive offsets start from the left end (offset 0 is the first item), and negatives count back from the right end (offset −1 is the last item). Either kind of offset can be used to give positions in indexing and slicing operations.

    到end但是不包含end:
    
    #+begin_src python
      In [44]: S = 'spam'

      In [45]: S[-1]
      Out[45]: 'm'

      In [47]: S[:-1]
      Out[47]: 'spa'

      In [48]: S[:2]
      Out[48]: 'sp'
    #+end_src

**** EXTENDED SLICING: THE THIRD LIMIT AND SLICE OBJECTS
     #+begin_src python
       >>> S = 'hello'
       >>> S[::−1]                            # Reversing items
       'olleh'
     #+end_src

     #+begin_src python
       >>> S = 'abcedfg'
       >>> S[5:1:−1]                          # Bounds roles differ
       'fdec'
     #+end_src

     #+begin_src python
       >>> 'spam'[1:3]                        # Slicing syntax
       'pa'
       >>> 'spam'[slice(1, 3)]                # Slice objects with index syntax + object
       'pa'
       >>> 'spam'[::-1]
       'maps'
       >>> 'spam'[slice(None, None, −1)]
       'maps'
     #+end_src
     
***** WHY YOU WILL CARE: SLICES
      #+begin_src python
	# File echo.py
	import sys
	print(sys.argv)

	% python echo.py −a −b −c
	['echo.py', '−a', '−b', '−c']
      #+end_src

      a single slice expression can be used to return all but the first item of a list. Here, ~sys.argv[1:]~ returns the desired list, ['−a', '−b', '−c']. You can then process this list without having to accommodate the program name at the front.
      
*** String Conversion Tools
    #+begin_src python
      >>> int("42"), str(42)          # Convert from/to string
      (42, '42')
      >>> repr(42)                    # Convert to as-code string
      '42'
    #+end_src
    The int function converts a string to a number, and the str function converts a number to its string representation (essentially, what it looks like when printed). The repr function (and the older backquotes expression, removed in Python 3.X) also converts an object to its string representation, but returns the object as a string of code that can be rerun to recreate the object.

**** CHARACTER CODE CONVERSIONS
     #+begin_src python
       >>> S = '5'
       >>> S = chr(ord(S) + 1)
       >>> S
       '6'
       >>> S = chr(ord(S) + 1)
       >>> S
       '7'
     #+end_src

     #+begin_src python
       >>> B = '1101'                 # Convert binary digits to integer with ord
       >>> I = 0
       >>> while B != '':
       ...     I = I * 2 + (ord(B[0]) - ord('0'))
       ...     B = B[1:]
       ...
       >>> I
       13
     #+end_src

     #+begin_src python
       >>> int('1101', 2)             # Convert binary to integer: built-in
       13
       >>> bin(13)                    # Convert integer to binary: built-in
       '0b1101'
     #+end_src

     #+begin_src python
       >>> 'That is %d %s bird!' % (1, 'dead')           # Format expression: all Pythons
       That is 1 dead bird!
       >>> 'That is {0} {1} bird!'.format(1, 'dead')     # Format method in 2.6, 2.7, 3.X
       'That is 1 dead bird!'
     #+end_src

** String Methods
   
*** Methods of Strings

    Table 7-3. String method calls in Python 3.3
    | S.capitalize()                       | S.ljust(width [, fill])                |
    | S.casefold()                         | S.lower()                              |
    | S.center(width [, fill])             | S.lstrip([chars])                      |
    | S.count(sub [, start [, end]])       | S.maketrans(x[, y[, z]])               |
    | S.encode([encoding [,errors]])       | S.partition(sep)                       |
    | S.endswith(suffix [, start [, end]]) | S.replace(old, new [, count])          |
    | S.expandtabs([tabsize])              | S.rfind(sub [,start [,end]])           |
    | S.find(sub [, start [, end]])        | S.rindex(sub [, start [, end]])        |
    | S.format(fmtstr, *args, **kwargs)    | S.rjust(width [, fill])                |
    | S.index(sub [, start [, end]])       | S.rpartition(sep)                      |
    | S.isalnum()                          | S.rsplit([sep[, maxsplit]])            |
    | S.isalpha()                          | S.rstrip([chars])                      |
    | S.isdecimal()                        | S.split([sep [,maxsplit]])             |
    | S.isdigit()                          | S.splitlines([keepends])               |
    | S.isidentifier()                     | S.startswith(prefix [, start [, end]]) |
    | S.islower()                          | S.strip([chars])                       |
    | S.isnumeric()                        | S.swapcase()                           |
    | S.isprintable()                      | S.title()                              |
    | S.isspace()                          | S.translate(map)                       |
    | S.istitle()                          | S.upper()                              |
    | S.isupper()                          | S.zfill(width)                         |
    | S.join(iterable)                     |                                        |

*** String Method Examples: Changing Strings II
    
    #+begin_src python
      >>> S = 'xxxxSPAMxxxxSPAMxxxx'
      >>> S.replace('SPAM', 'EGGS')         # Replace all
      'xxxxEGGSxxxxEGGSxxxx'

      >>> S.replace('SPAM', 'EGGS', 1)      # Replace one
      'xxxxEGGSxxxxSPAMxxxx'
    #+end_src

    #+begin_src python
      >>> line = 'bob,hacker,40'
      >>> line.split(',')
      ['bob', 'hacker', '40']
    #+end_src

    #+begin_src python
      >>> line = "i'mSPAMaSPAMlumberjack"
      >>> line.split("SPAM")
      ["i'm", 'a', 'lumberjack']
    #+end_src

** String Formatting Expressions
   #+begin_src python
     >>> template = '{0}, {1} and {2}'                             # By position
     >>> template.format('spam', 'ham', 'eggs')
     'spam, ham and eggs'

     >>> template = '{motto}, {pork} and {food}'                   # By keyword
     >>> template.format(motto='spam', pork='ham', food='eggs')
     'spam, ham and eggs'

     >>> template = '{motto}, {0} and {food}'                      # By both
     >>> template.format('ham', motto='spam', food='eggs')
     'spam, ham and eggs'

     >>> template = '{}, {} and {}'                                # By relative position
     >>> template.format('spam', 'ham', 'eggs')                    # New in 3.1 and 2.7
     'spam, ham and eggs'
   #+end_src

*** Adding Keys, Attributes, and Offsets

    #+begin_src python
      >>> import sys

      >>> 'My {1[kind]} runs {0.platform}'.format(sys, {'kind': 'laptop'})
      'My laptop runs win32'

      >>> 'My {map[kind]} runs {sys.platform}'.format(sys=sys, map={'kind': 'laptop'})
      'My laptop runs win32'
    #+end_src

** General Type Categories
   - Numbers (integer, floating-point, decimal, fraction, others)
     
     Support addition, multiplication, etc.

   - Sequences (strings, lists, tuples)

     Support indexing, slicing, concatenation, etc.
     
   - Mappings (dictionaries)

     Support indexing by key, etc.


     
*** Mutable Types Can Be Changed in Place

    - Immutables (numbers, strings, tuples, frozensets)

      None of the object types in the immutable category support in-place changes, though we can always run expressions to make new objects and assign their results to variables as needed.
      
    - Mutables (lists, dictionaries, sets, bytearray)

      Conversely, the mutable types can always be changed in place with operations that do not create new objects. Although such objects can be copied, in-place changes support direct modification.

* Lists and Dictionaries

* Tuples, Files, and Everything Else

** Tuples
   - Ordered collections of arbitrary objects

     Like strings and lists, tuples are positionally ordered collections of objects (i.e., they maintain a left-to-right order among their contents); like lists, they can embed any kind of object.

   - Accessed by offset
     
     Like strings and lists, items in a tuple are accessed by offset (not by key); they support all the offset-based access operations, such as indexing and slicing.

   - Of the category “immutable sequence”

     Like strings and lists, tuples are sequences; they support many of the same operations. However, like strings, tuples are immutable; they don’t support any of the in-place change operations applied to lists.

   - Fixed-length, heterogeneous, and arbitrarily nestable

     Because tuples are immutable, you cannot change the size of a tuple without making a copy. On the other hand, tuples can hold any type of object, including other compound objects (e.g., lists, dictionaries, other tuples), and so support arbitrary nesting.

   - Arrays of object references

     Like lists, tuples are best thought of as object reference arrays; tuples store access points to other objects (references), and indexing a tuple is relatively quick.

*** Tuples in Action
    #+begin_src python
      >>> (1, 2) + (3, 4)            # Concatenation
      (1, 2, 3, 4)

      >>> (1, 2) * 4                 # Repetition
      (1, 2, 1, 2, 1, 2, 1, 2)

      >>> T = (1, 2, 3, 4)           # Indexing, slicing
      >>> T[0], T[1:3]
      (1, (2, 3))
    #+end_src

**** TUPLE SYNTAX PECULIARITIES: COMMAS AND PARENTHESES
     #+begin_src python
       >>> x = (40)                   # An integer!
       >>> x
       40
       >>> y = (40,)                  # A tuple containing an integer
       >>> y
       (40,)
     #+end_src

**** CONVERSIONS, METHODS, AND IMMUTABILITY
     #+begin_src python
       >>> T = ('cc', 'aa', 'dd', 'bb')
       >>> tmp = list(T)                  # Make a list from a tuple's items
       >>> tmp.sort()                     # Sort the list
       >>> tmp
       ['aa', 'bb', 'cc', 'dd']
       >>> T = tuple(tmp)                 # Make a tuple from the list's items
       >>> T
       ('aa', 'bb', 'cc', 'dd')

       >>> sorted(T)                      # Or use the sorted built-in, and save two steps
       ['aa', 'bb', 'cc', 'dd']
     #+end_src
     
     #+begin_src python
       >>> T = (1, 2, 3, 2, 4, 2)         # Tuple methods in 2.6, 3.0, and later
       >>> T.index(2)                     # Offset of first appearance of 2
       1
       >>> T.index(2, 2)                  # Offset of appearance after offset 2
       3
       >>> T.count(2)                     # How many 2s are there?
       3
     #+end_src

     #+begin_src python
       >>> T = (1, [2, 3], 4)
       >>> T[1] = 'spam'                  # This fails: can't change tuple itself
       TypeError: object doesn't support item assignment

       >>> T[1][0] = 'spam'               # This works: can change mutables inside
       >>> T
       (1, ['spam', 3], 4)
     #+end_src

*** Why Lists and Tuples?
    Tuples can also be used in places that lists cannot—for example, as dictionary keys (see the sparse matrix example in Chapter 8). Some built-in operations may also require or imply tuples instead of lists (e.g., the substitution values in a string format expression), though such operations have often been generalized in recent years to be more flexible. As a rule of thumb, lists are the tool of choice for ordered collections that might need to change; tuples can handle the other cases of fixed associations.

*** Records Revisited: Named Tuples
    #+begin_src python
      >>> from collections import namedtuple                     # Import extension type
      >>> Rec = namedtuple('Rec', ['name', 'age', 'jobs'])       # Make a generated class
      >>> bob = Rec('Bob', age=40.5, jobs=['dev', 'mgr'])        # A named-tuple record
      >>> bob
      Rec(name='Bob', age=40.5, jobs=['dev', 'mgr'])

      >>> bob[0], bob[2]                                         # Access by position
      ('Bob', ['dev', 'mgr'])
      >>> bob.name, bob.jobs                                     # Access by attribute
      ('Bob', ['dev', 'mgr'])
    #+end_src
    
    Converting to a dictionary supports key-based behavior when needed:

    #+begin_src python
      >>> O = bob._asdict()                                      # Dictionary-like form
      >>> O['name'], O['jobs']                                   # Access by key too
      ('Bob', ['dev', 'mgr'])
      >>> O
      OrderedDict([('name', 'Bob'), ('age', 40.5), ('jobs', ['dev', 'mgr'])])
    #+end_src

     named tuples are a tuple/class/dictionary hybrid. 

     #+begin_src python
       >>> bob = Rec('Bob', 40.5, ['dev', 'mgr'])    # For both tuples and named tuples
       >>> name, age, jobs = bob                     # Tuple assignment (Chapter 11)
       >>> name, jobs
       ('Bob', ['dev', 'mgr'])

       >>> for x in bob: print(x)                    # Iteration context (Chapters 14, 20)
       ...prints Bob, 40.5, ['dev', 'mgr']...
     #+end_src

     #+begin_src python
       >>> bob = {'name': 'Bob', 'age': 40.5, 'jobs': ['dev', 'mgr']}
       >>> job, name, age = bob.values()
       >>> name, job                                 # Dict equivalent (but order may vary)
       ('Bob', ['dev', 'mgr'])

       >>> for x in bob: print(bob[x])               # Step though keys, index values
       ...prints values...
       >>> for x in bob.values(): print(x)           # Step through values view
       ...prints values...
     #+end_src

** Files

   | Operation                             | Interpretation                                        |
   | output = open(r'C:\spam', 'w')        | Create output file ('w' means write)                  |
   | input = open('data', 'r')             | Create input file ('r' means read)                    |
   | input = open('data')                  | Same as prior line ('r' is the default)               |
   | aString = input.read()                | Read entire file into a single string                 |
   | aString = input.read(N)               | Read up to next N characters (or bytes) into a string |
   | aString = input.readline()            | Read next line (including \n newline) into a string   |
   | aList = input.readlines()             | Read entire file into list of line strings (with \n)  |
   | output.write(aString)                 | Write a string of characters (or bytes) into file     |
   | output.writelines(aList)              | Write all line strings in a list into file            |
   | output.close()                        | Manual close (done for you when file is collected)    |
   | output.flush()                        | Flush output buffer to disk without closing           |
   | anyFile.seek(N)                       | Change file position to offset N for next operation   |
   | for line in open('data'): use line    | File iterators read line by line                      |
   | open('f.txt', encoding='latin-1')     | Python 3.X Unicode text files (str strings)           |
   | open('f.bin', 'rb')                   | Python 3.X bytes files (bytes strings)                |
   | codecs.open('f.txt', encoding='utf8') | Python 2.X Unicode text files (unicode strings)       |
   | open('f.bin', 'rb')                   | Python 2.X bytes files (str strings)                  |

*** Opening Files
    #+begin_src python
      afile = open(filename, mode)
      afile.method()
    #+end_src
    
    The second argument to open, processing mode, is typically the string 'r' to open for text input (the default), 'w' to create and open for text output, or 'a' to open for appending text to the end (e.g., for adding to logfiles). The processing mode argument can specify additional options:

    Adding a b to the mode string allows for binary data (end-of-line translations and 3.X Unicode encodings are turned off).

    Adding a + opens the file for both input and output (i.e., you can both read and write to the same file object, often in conjunction with seek operations to reposition in the file).

*** Files in Action

    #+begin_src python
      >>> myfile = open('myfile.txt', 'w')        # Open for text output: create/empty
      >>> myfile.write('hello text file\n')       # Write a line of text: string
      16
      >>> myfile.write('goodbye text file\n')
      18
      >>> myfile.close()                          # Flush output buffers to disk

      >>> myfile = open('myfile.txt')             # Open for text input: 'r' is default
      >>> myfile.readline()                       # Read the lines back
      'hello text file\n'
      >>> myfile.readline()
      'goodbye text file\n'
      >>> myfile.readline()                       # Empty string: end-of-file
      ''
    #+end_src

    #+begin_src python
      >>> open('myfile.txt').read()               # Read all at once into string
      'hello text file\ngoodbye text file\n'

      >>> print(open('myfile.txt').read())        # User-friendly display
      hello text file
      goodbye text file
    #+end_src

    #+begin_src python
      >>> for line in open('myfile.txt'):         # Use file iterators, not reads
      ...     print(line, end='')
      ...
      hello text file
      goodbye text file
    #+end_src

*** Storing Native Python Objects: pickle
    The pickle module is a more advanced tool that allows us to store almost any Python object in a file directly, with no to- or from-string conversion requirement on our part. It’s like a super-general data formatting and parsing utility. To store a dictionary in a file, for instance, we pickle it directly:
    #+begin_src python
      >>> D = {'a': 1, 'b': 2}
      >>> F = open('datafile.pkl', 'wb')
      >>> import pickle
      >>> pickle.dump(D, F)                          # Pickle any object to file
      >>> F.close()
    #+end_src

    Then, to get the dictionary back later, we simply use pickle again to re-create it:
    #+begin_src python
      >>> F = open('datafile.pkl', 'rb')
      >>> E = pickle.load(F)                         # Load any object from file
      >>> E
      {'a': 1, 'b': 2}
    #+end_src

*** Storing Python Objects in JSON Format
    #+begin_src python
      >>> name = dict(first='Bob', last='Smith')
      >>> rec  = dict(name=name, job=['dev', 'mgr'], age=40.5)
      >>> rec
      {'job': ['dev', 'mgr'], 'name': {'last': 'Smith', 'first': 'Bob'}, 'age': 40.5}
    #+end_src
    The final dictionary format displayed here is a valid literal in Python code, and almost passes for JSON when printed as is, but the json module makes the translation official—here translating Python objects to and from a JSON serialized string representation in memory:
    #+begin_src python
      >>> import json
      >>> json.dumps(rec)
      '{"job": ["dev", "mgr"], "name": {"last": "Smith", "first": "Bob"}, "age": 40.5}'

      >>> S = json.dumps(rec)
      >>> S
      '{"job": ["dev", "mgr"], "name": {"last": "Smith", "first": "Bob"}, "age": 40.5}'

      >>> O = json.loads(S)
      >>> O
      {'job': ['dev', 'mgr'], 'name': {'last': 'Smith', 'first': 'Bob'}, 'age': 40.5}
      >>> O == rec
      True
    #+end_src

    It’s similarly straightforward to translate Python objects to and from JSON data strings in files. Prior to being stored in a file, your data is simply Python objects; the JSON module recreates them from the JSON textual representation when it loads it from the file:
    #+begin_src python
      >>> json.dump(rec, fp=open('testjson.txt', 'w'), indent=4)
      >>> print(open('testjson.txt').read())
      {
	  "job": [
	      "dev",
	      "mgr"
	  ],
	  "name": {
	      "last": "Smith",
	      "first": "Bob"
	  },
	  "age": 40.5
      }
      >>> P = json.load(open('testjson.txt'))
      >>> P
      {'job': ['dev', 'mgr'], 'name': {'last': 'Smith', 'first': 'Bob'}, 'age': 40.5}
    #+end_src

*** CVS
    #+begin_src python
      >>> import csv
      >>> rdr = csv.reader(open('csvdata.txt'))
      >>> for row in rdr: print(row)
      ...
      ['a', 'bbb', 'cc', 'dddd']
      ['11', '22', '33', '44']
    #+end_src

*** Storing Packed Binary Data: struct
    We saw an overview of this tool in Chapter 4, but let’s take another quick look here for more perspective. To create a packed binary data file, open it in 'wb' (write binary) mode, and pass struct a format string and some Python objects. The format string used here means pack as a 4-byte integer, a 4-character string (which must be a bytes string as of Python 3.2), and a 2-byte integer, all in big-endian form (other format codes handle padding bytes, floating-point numbers, and more):
    #+begin_src python
      >>> F = open('data.bin', 'wb')                     # Open binary output file
      >>> import struct
      >>> data = struct.pack('>i4sh', 7, b'spam', 8)     # Make packed binary data
      >>> data
      b'\x00\x00\x00\x07spam\x00\x08'
      >>> F.write(data)                                  # Write byte string
      >>> F.close()
    #+end_src

    Python creates a binary bytes data string, which we write out to the file normally—this one consists mostly of nonprintable characters printed in hexadecimal escapes, and is the same binary file we met earlier. To parse the values out to normal Python objects, we simply read the string back and unpack it using the same format string. Python extracts the values into normal Python objects—integers and a string:
    #+begin_src python
      >>> F = open('data.bin', 'rb')
      >>> data = F.read()                                # Get packed binary data
      >>> data
      b'\x00\x00\x00\x07spam\x00\x08'
      >>> values = struct.unpack('>i4sh', data)          # Convert to Python objects
      >>> values
      (7, b'spam', 8)
    #+end_src

    
*** File Context Managers

    #+begin_src python
      with open(r'C:\code\data.txt') as myfile:     # See Chapter 34 for details
	  for line in myfile:
	      ...use line here...
    #+end_src

** Core Types Review and Summary

   - Objects share operations according to their category; for instance, sequence objects—strings, lists, and tuples—all share sequence operations such as concatenation, length, and indexing.

   - Only mutable objects—lists, dictionaries, and sets—may be changed in place; you cannot change numbers, strings, or tuples in place.

   - Files export only methods, so mutability doesn’t really apply to them—their state may be changed when they are processed, but this isn’t quite the same as Python core type mutability constraints.

   - “Numbers” in Table 9-3 includes all number types: integer (and the distinct long integer in 2.X), floating point, complex, decimal, and fraction.

   - “Strings” in Table 9-3 includes str, as well as bytes in 3.X and unicode in 2.X; the bytearray string type in 3.X, 2.6, and 2.7 is mutable.

   - Sets are something like the keys of a valueless dictionary, but they don’t map to values and are not ordered, so sets are neither a mapping nor a sequence type; frozenset is an immutable variant of set.

   - In addition to type category operations, as of Python 2.6 and 3.0 all the types in Table 9-3 have callable methods, which are generally specific to their type.

   Table 9-3. Object classifications
   
   | Object type   | Category  | Mutable? |
   | Numbers (all) | Numeric   | No       |
   | Strings (all) | Sequence  | No       |
   | Lists         | Sequence  | Yes      |
   | Dictionaries  | Mapping   | Yes      |
   | Tuples        | Sequence  | No       |
   | Files         | Extension | N/A      |
   | Sets          | Set       | Yes      |
   | Frozenset     | Set       | No       |
   | bytearray     | Sequence  | Yes      |

*** Object Flexibility

    This part of the book introduced a number of compound object types—collections with components. In general:
    
    - Lists, dictionaries, and tuples can hold any kind of object.
      
      #+begin_src python
	In [71]: b = ([1,2], 3, 4)

	In [72]: b
	Out[72]: ([1, 2], 3, 4)
      #+end_src

    - Sets can contain any type of immutable object.

      #+begin_src python
	In [68]: a.add([1, 2])
	---------------------------------------------------------------------------
	TypeError                                 Traceback (most recent call last)
	<ipython-input-68-e2fb23224f38> in <module>
	----> 1 a.add([1, 2])

	TypeError: unhashable type: 'list'
      #+end_src

    - Lists, dictionaries, and tuples can be arbitrarily nested.

    - Lists, dictionaries, and sets can dynamically grow and shrink.

      
[[file:./img/lp5e_0903.png]]

*** Assignment Creates References, Not Copies

*** Repetition Adds One Level Deep

*** Beware of Cyclic Data Structures
    #+begin_src python
      >>> L = ['grail']                # Append reference to same object
      >>> L.append(L)                  # Generates cycle in object: [...]
      >>> L
      ['grail', [...]]
    #+end_src

*** Immutable Types Can’t Be Changed in Place

* Chapter 10. Introducing Python Statements

** The Python Conceptual Hierarchy Revisited
   
   - Programs are composed of modules.

   - Modules contain statements.

   - Statements contain expressions.

   - Expressions create and process objects.

** Python’s Statements
   
   Table 10-1. Python statements
   | Statement                   | Role                         | Example                                                                   |
   | Assignment                  | Creating references          | a, b = 'good', 'bad'                                                      |
   | Calls and other expressions | Running functions            | log.write("spam, ham")                                                    |
   | print calls                 | Printing objects             | print('The Killer', joke)                                                 |
   | if/elif/else                | Selecting actions            | if "python" in text:    print(text)                                       |
   | for/else                    | Iteration                    | for x in mylist:                                                          |
   | print(x) while/else         | General loops                | while X > Y:    print('hello')                                            |
   | pass                        | Empty placeholder            | while True:    pass                                                       |
   | break                       | Loop exit                    | while True:    if exittest(): break                                       |
   | continue                    | Loop continue                | while True:    if skiptest(): continue                                    |
   | def                         | Functions and methods        | def f(a, b, c=1, *d):    print(a+b+c+d[0])                                |
   | return                      | Functions results            | def f(a, b, c=1, *d):    return a+b+c+d[0]                                |
   | yield                       | Generator functions          | def gen(n):    for i in n: yield i*2                                      |
   | global                      | Namespaces                   | x = 'old' def function():    global x, y; x = 'new'                       |
   | nonlocal                    | Namespaces (3.X)             | def outer():    x = 'old'    def function():        nonlocal x; x = 'new' |
   | import                      | Module access                | import sys                                                                |
   | from                        | Attribute access             | from sys import stdin                                                     |
   | class                       | Building objects             | class Subclass(Superclass):    staticData = []    def method(self): pass  |
   | try/except/ finally         | Catching exceptions          | try:    action() except:    print('action error')                         |
   | raise                       | Triggering exceptions        | raise EndSearch(location)                                                 |
   | assert                      | Debugging checks             | assert X > Y, 'X too small'                                               |
   | with/as                     | Context managers (3.X, 2.6+) | with open('data') as myfile:    process(myfile)                           |
   | del                         | Deleting references          | del data[k] del data[i:j] del obj.attr del variable                       |

* Chapter 11. Assignments, Expressions, and Prints
** Assignment Statements
*** Extended Sequence Unpacking in Python 3.X
    #+begin_src python
      In [83]: a, *b = [1, 2, 3, 4]

      In [84]: a
      Out[84]: 1

      In [85]: b
      Out[85]: [2, 3, 4]
    #+end_src

    #+begin_src python
      >>> a, *b, c = range(4)
      >>> a, b, c
      (0, [1, 2], 3)
    #+end_src

    #+begin_src python
      >>> L = [1, 2, 3, 4]
      >>> while L:
      ...     front, *L = L                    # Get first, rest without slicing
      ...     print(front, L)
      ...
      1 [2, 3, 4]
      2 [3, 4]
      3 [4]
      4 []
    #+end_src
**** MULTIPLE-TARGET ASSIGNMENT AND SHARED REFERENCES
     #+begin_src python
       >>> a = b = []
       >>> b.append(42)
       >>> a, b
       ([42], [42])
     #+end_src
*** Augmented Assignments
    #+begin_src python
      >>> L = []
      >>> L += 'spam'                 # += and extend allow any sequence, but + does not!
      >>> L
      ['s', 'p', 'a', 'm']
      >>> L = L + 'spam'
      TypeError: can only concatenate list (not "str") to list
    #+end_src
**** AUGMENTED ASSIGNMENT AND SHARED REFERENCES
     #+begin_src python
       >>> L = [1, 2]
       >>> M = L                       # L and M reference the same object
       >>> L = L + [3, 4]              # Concatenation makes a new object
       >>> L, M                        # Changes L but not M
       ([1, 2, 3, 4], [1, 2])

       >>> L = [1, 2]
       >>> M = L
       >>> L += [3, 4]                 # But += really means extend
       >>> L, M                        # M sees the in-place change too!
       ([1, 2, 3, 4], [1, 2, 3, 4])
     #+end_src
*** Variable Name Rules
    Table 11-3. Python 3.X reserved words
    
    | False | class  | finally | is     | return | None | continue |
    | for   | lambda | try     | True   | def    | from | nonlocal |
    | while | and    | del     | global | not    | with | as       |
    | elif  | if     | or      | yield  | assert | else | import   |
    | pass  | break  | except  | in     | raise  |      |          |
**** NAMING CONVENTIONS

     - Names that begin with a single underscore (_X) are not imported by a from module import * statement (described in Chapter 23).

     - Names that have two leading and trailing underscores (__X__) are system-defined names that have special meaning to the interpreter.

     - Names that begin with two underscores and do not end with two more (__X) are localized (“mangled”) to enclosing classes (see the discussion of pseudoprivate attributes in Chapter 31).

     - The name that is just a single underscore (_) retains the result of the last expression when you are working interactively.

** Expression Statements
   Expressions are commonly used as statements in two situations:

   - For calls to functions and methods

     Some functions and methods do their work without returning a value. Such functions are sometimes called procedures in other languages. Because they don’t return values that you might be interested in retaining, you can call these functions with expression statements.

   - For printing values at the interactive prompt

     Python echoes back the results of expressions typed at the interactive command line. Technically, these are expression statements, too; they serve as a shorthand for typing print statements.

   Table 11-4. Common Python expression statements
   | Operation              | Interpretation                                    |
   | spam(eggs, ham)        | Function calls                                    |
   | spam.ham(eggs)         | Method calls                                      |
   | spam                   | Printing variables in the interactive interpreter |
   | print(a, b, c, sep='') | Printing operations in Python 3.X                 |
   | yield x ** 2           | Yielding expression statements                    |

*** Expression Statements and In-Place Changes
    
    #+begin_src python
      >>> L = [1, 2]
      >>> L.append(3)               # Append is an in-place change
      >>> L
      [1, 2, 3]
    #+end_src

    However, it’s not unusual for Python newcomers to code such an operation as an assignment statement instead, intending to assign L to the larger list:
    
    #+begin_src python
      >>> L = L.append(4)           # But append returns None, not L
      >>> print(L)                  # So we lose our list!
      None
    #+end_src

** Print Operations
   
*** The Python 3.X print Function

**** CALL FORMAT
     #+begin_src python
       print([object, ...][, sep=' '][, end='\n'][, file=sys.stdout][, flush=False])
     #+end_src

**** THE 3.X PRINT FUNCTION IN ACTION
     #+begin_src python
       C:\code> c:\python33\python
       >>> print()                                      # Display a blank line

       >>> x = 'spam'
       >>> y = 99
       >>> z = ['eggs']
       >>>
       >>> print(x, y, z)                               # Print three objects per defaults
       spam 99 ['eggs']
     #+end_src

     #+begin_src python
       >>> print(x, y, z, sep='')                       # Suppress separator
       spam99['eggs']
       >>>
       >>> print(x, y, z, sep=', ')                     # Custom separator
       spam, 99, ['eggs']
     #+end_src

     #+begin_src python
       >>> print(x, y, z, end='')                        # Suppress line break
       spam 99 ['eggs']>>>
       >>>
       >>> print(x, y, z, end=''); print(x, y, z)        # Two prints, same output line
       spam 99 ['eggs']spam 99 ['eggs']
       >>> print(x, y, z, end='...\n')                   # Custom line end
       spam 99 ['eggs']...
       >>>
     #+end_src

     #+begin_src python
       >>> print(x, y, z, sep='...', file=open('data.txt', 'w'))      # Print to a file
       >>> print(x, y, z)                                             # Back to stdout
       spam 99 ['eggs']
       >>> print(open('data.txt').read())                             # Display file text
       spam...99...['eggs']
     #+end_src

**** THE PYTHON “HELLO WORLD” PROGRAM
     #+begin_src python
       >>> import sys                         # Printing the hard way
       >>> sys.stdout.write('hello world\n')
       hello world
     #+end_src

**** MANUAL STREAM REDIRECTION
     #+begin_src python
       import sys
       sys.stdout = open('log.txt', 'a')       # Redirects prints to a file
       ...
       print(x, y, x)                          # Shows up in log.txt
     #+end_src

**** AUTOMATIC STREAM REDIRECTION
     #+begin_src python
       C:\code> c:\python33\python
       >>> import sys
       >>> temp = sys.stdout                   # Save for restoring later
       >>> sys.stdout = open('log.txt', 'a')   # Redirect prints to a file
       >>> print('spam')                       # Prints go to file, not here
       >>> print(1, 2, 3)
       >>> sys.stdout.close()                  # Flush output to disk
       >>> sys.stdout = temp                   # Restore original stream

       >>> print('back here')                  # Prints show up here again
       back here
       >>> print(open('log.txt').read())       # Result of earlier prints
       spam
       1 2 3
     #+end_src
     
     #+begin_src python
       >>> X = 1; Y = 2
       >>> print(X, Y)                                            # Print: the easy way
       1 2
       >>> import sys                                             # Print: the hard way
       >>> sys.stdout.write(str(X) + ' ' + str(Y) + '\n')
       1 2
       4
       >>> print(X, Y, file=open('temp1', 'w'))                   # Redirect text to file

       >>> open('temp2', 'w').write(str(X) + ' ' + str(Y) + '\n') # Send to file manually
       4
       >>> print(open('temp1', 'rb').read())                      # Binary mode for bytes
       b'1 2\r\n'
       >>> print(open('temp2', 'rb').read())
       b'1 2\r\n'
     #+end_src

* Chapter 12. if Tests and Syntax Rules

** if Statements

*** HANDLING LARGER ACTIONS
    #+begin_src python
      def function(): ...
      def default(): ...

      branch = {'spam': lambda: ...,             # A table of callable function objects
		'ham':  function,
		'eggs': lambda: ...}

      branch.get(choice, default)()
    #+end_src
    
    使用字典来实现对应函数的调用, 但是用if语句可能会更加直接.

** Python Syntax Revisited

* Chapter 13. while and for Loops

** while Loops

*** General Format
    #+begin_src python
      while test:                     # Loop test
	  statements                  # Loop body
      else:                           # Optional else
	  statements                  # Run if didn't exit loop with break
    #+end_src

** break, continue, pass, and the Loop else
   - break

     Jumps out of the closest enclosing loop (past the entire loop statement)

   - continue

     Jumps to the top of the closest enclosing loop (to the loop’s header line)

   - pass

     Does nothing at all: it’s an empty statement placeholder

   - Loop else block

     Runs if and only if the loop is exited normally (i.e., without hitting a break)

*** General Loop Format
    #+begin_src python
      while test:
	  statements
	  if test: break                 # Exit loop now, skip else if present
	  if test: continue              # Go to test at top of loop now
      else:
	  statements                     # Run if we didn't hit a 'break'
    #+end_src

*** Loop else

    不是由break终结情况下则进入到Loop else语句块中
    #+begin_src python
      x = y // 2                                # For some y > 1
      while x > 1:
	  if y % x == 0:                        # Remainder
	      print(y, 'has factor', x)
	      break                             # Skip else
	  x -= 1
      else:                                     # Normal exit
	  print(y, 'is prime')
    #+end_src

    如果进入不了While循环, 则也会进入到else语句, 有点类似 ~do..while~ 语句

    #+begin_src python
      while x:                             # Exit when x empty
	  if match(x[0]):
	      print('Ni')
	      break                        # Exit, go around else
	  x = x[1:]
      else:
	  print('Not found')               # Only here if exhausted x
    #+end_src

** for Loops

*** General Format
    #+begin_src python
      for target in object:                 # Assign object items to target
	  statements                        # Repeated loop body: use target
      else:                                 # Optional else part
	  statements                        # If we didn't hit a 'break'
    #+end_src

** Loop Coding Techniques
   
   - The built-in range function (available since Python 0.X) produces a series of successively higher integers, which can be used as indexes in a for.

   - The built-in zip function (available since Python 2.0) returns a series of parallel-item tuples, which can be used to traverse multiple sequences in a for.

   - The built-in enumerate function (available since Python 2.3) generates both the values and indexes of items in an iterable, so we don’t need to count manually.

   - The built-in map function (available since Python 1.0) can have a similar effect to zip in Python 2.X, though this role is removed in 3.X.

*** Counter Loops: range
    
    #+begin_src python
      >>> list(range(5)), list(range(2, 5)), list(range(0, 10, 2))
      ([0, 1, 2, 3, 4], [2, 3, 4], [0, 2, 4, 6, 8])
    #+end_src

*** Sequence Scans: while and range Versus for
    #+begin_src python
      >>> X = 'spam'
      >>> for item in X: print(item, end=' ')           # Simple iteration
      ...
      s p a m
    #+end_src
    
    #+begin_src python
      >>> i = 0
      >>> while i < len(X):                             # while loop iteration
      ...     print(X[i], end=' ')
      ...     i += 1
      ...
      s p a m
    #+end_src

*** Nonexhaustive Traversals: range Versus Slices

    #+begin_src python
      >>> S = 'abcdefghijk'
      >>> for c in S[::2]: print(c, end=' ')
      ...
      a c e g i k
    #+end_src

*** Changing Lists: range Versus Comprehensions
    #+begin_src python
      [x + 1 for x in L]
    #+end_src

** Parallel Traversals: zip and map
   #+begin_src python
     >>> T1, T2, T3 = (1,2,3), (4,5,6), (7,8,9)
     >>> T3
     (7, 8, 9)
     >>> list(zip(T1, T2, T3))                   # Three tuples for three arguments
     [(1, 4, 7), (2, 5, 8), (3, 6, 9)]
   #+end_src
   
   zip truncates result tuples at the length of the shortest sequence when the argument lengths differ. 

   #+begin_src python
     >>> S1 = 'abc'
     >>> S2 = 'xyz123'
     >>>
     >>> list(zip(S1, S2))                       # Truncates at len(shortest)
     [('a', 'x'), ('b', 'y'), ('c', 'z')]
   #+end_src


   #+begin_src python
     >>> list(map(ord, 'spam'))
     [115, 112, 97, 109]
   #+end_src

*** DICTIONARY CONSTRUCTION WITH ZIP
    #+begin_src python
      >>> keys = ['spam', 'eggs', 'toast']
      >>> vals = [1, 3, 5]

      >>> D3 = dict(zip(keys, vals))
      >>> D3
      {'eggs': 3, 'toast': 5, 'spam': 1}
    #+end_src

    #+begin_src python
      >>> {k: v for (k, v) in zip(keys, vals)}
      {'eggs': 3, 'toast': 5, 'spam': 1}
    #+end_src

** Generating Both Offsets and Items: enumerate
   #+begin_src python
     >>> S = 'spam'
     >>> for (offset, item) in enumerate(S):
     ...     print(item, 'appears at offset', offset)
     ...
     s appears at offset 0
     p appears at offset 1
     a appears at offset 2
     m appears at offset 3
   #+end_src

   #+begin_src python
     >>> E = enumerate(S)
     >>> E
     <enumerate object at 0x0000000002A8B900>
     >>> next(E)
     (0, 's')
     >>> next(E)
     (1, 'p')
     >>> next(E)
     (2, 'a')
   #+end_src

   #+begin_src python
     >>> [c * i for (i, c) in enumerate(S)]
     ['', 'p', 'aa', 'mmm']

     >>> for (i, l) in enumerate(open('test.txt')):
     ...     print('%s) %s' % (i, l.rstrip()))
     ...
     0) aaaaaa
     1) bbbbbb
     2) cccccc
   #+end_src

* Chapter 14. Iterations and Comprehensions

** Iterations: A First Look
   #+begin_src python
     >>> for x in [1, 2, 3, 4]: print(x ** 2, end=' ')            # In 2.X: print x ** 2,
     ...
     1 4 9 16

     >>> for x in (1, 2, 3, 4): print(x ** 3, end=' ')
     ...
     1 8 27 64

     >>> for x in 'spam': print(x * 2, end=' ')
     ...
     ss pp aa mm
   #+end_src
   
   *Iteration*

   It’s essentially a generalization of the notion of sequences—an object is considered iterable if it is either a physically stored sequence, or an object that produces one result at a time in the context of an iteration tool like a for loop. In a sense, iterable objects include both physical sequences and virtual sequences computed on demand.
   
   迭代器的通用表示-如果一个对象物理存储是顺序的,或者一次可以生成一个结果, 我们就认为这是一个可迭代对象.

*** The Iteration Protocol: File Iterators
    
    #+begin_src python
      >>> f = open('script2.py')     # __next__ loads one line on each call too
      >>> f.__next__()               # But raises an exception at end-of-file
      'import sys\n'
      >>> f.__next__()               # Use f.next() in 2.X, or next(f) in 2.X or 3.X
      'print(sys.path)\n'
      >>> f.__next__()
      'x = 2\n'
      >>> f.__next__()
      'print(x ** 32)\n'
      >>> f.__next__()
      Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
      StopIteration
    #+end_src

    This interface is most of what we call the iteration protocol in Python. Any object with a ~__next__~ method to advance to a next result, which raises StopIteration at the end of the series of results, is considered an iterator in Python. Any such object may also be stepped through with a for loop or other iteration tool, because all iteration tools normally work internally by calling ~__next__~ on each iteration and catching the StopIteration exception to determine when to exit. 

    一个对象,如果提供了 ~__next__~ 方法来生成新的结果, 结果的末尾返回 ~StopIteration~ 异常, 我们就称之为迭代器( *iterator* )

    #+begin_src python
      >>> for line in open('script2.py'):       # Use file iterators to read by lines
      ...     print(line.upper(), end='')       # Calls __next__, catches StopIteration
      ...
      IMPORT SYS
      PRINT(SYS.PATH)
      X = 2
      PRINT(X ** 32)
    #+end_src

*** Manual Iteration: iter and next
    #+begin_src python
      >>> L = [1, 2, 3]
      >>> I = iter(L)                    # Obtain an iterator object from an iterable
      >>> I.__next__()                   # Call iterator's next to advance to next item
      1
      >>> I.__next__()                   # Or use I.next() in 2.X, next(I) in either line
      2
      >>> I.__next__()
      3
      >>> I.__next__()
      ...error text omitted...
      StopIteration
    #+end_src

    This initial step is not required for files, because a file object is its own iterator. Because they support just one iteration (they can’t seek backward to support multiple active scans), files have their own ~__next__~ method and do not need to return a different object that does:
    #+begin_src python
      >>> f = open('script2.py')
      >>> iter(f) is f
      True
      >>> iter(f) is f.__iter__()
      True
      >>> f.__next__()
      'import sys\n'
    #+end_src

    通常来说, 需要使用 ~iter()~ 方法获取到可迭代对象(~iterable~)的迭代器(~iterator~), 再调用该迭代器的 ~__next__~ 方法来获取下一个结果.
    
    但是file比较特殊, 它的迭代器就是自身. 因为file无法迭代多次, 所以简化了处理.

    #+begin_src python
      In [146]: L
      Out[146]: [1, 2, 3]

      In [149]: l = iter(L)

      In [150]: i = iter(L)
    #+end_src

    上面的示例中, l和i都是L的迭代器, L称之为可迭代对象


*** MANUAL ITERATION
    #+begin_src python
      >>> L = [1, 2, 3]
      >>>
      >>> for X in L:                 # Automatic iteration
      ...     print(X ** 2, end=' ')  # Obtains iter, calls __next__, catches exceptions
      ...
      1 4 9

      >>> I = iter(L)                 # Manual iteration: what for loops usually do
      >>> while True:
      ...     try:                    # try statement catches exceptions
      ...         X = next(I)         # Or call I.__next__ in 3.X
      ...     except StopIteration:
      ...         break
      ...     print(X ** 2, end=' ')
      ...
      1 4 9
    #+end_src

*** Other Built-in Type Iterables

    #+begin_src python
      In [2]: L = [1, 2, 3, 4]

      In [3]: S = "swamp"

      In [4]: D = {k:v for k, v in zip(L, S)}

      In [5]: D
      Out[5]: {1: 's', 2: 'w', 3: 'a', 4: 'm'}

      In [6]: for key in D:
	 ...:     print(key, D[key])
	 ...:
      1 s
      2 w
      3 a
      4 m
    #+end_src

** List Comprehensions: A First Detailed Look
*** Using List Comprehensions on Files

    #+begin_src python
      >>> lines = [line.rstrip() for line in open('script2.py')]
      >>> lines
      ['import sys', 'print(sys.path)', 'x = 2', 'print(x ** 32)']
    #+end_src
*** Extended List Comprehension Syntax
**** FILTER CLAUSES: IF
     #+begin_src python
       >>> lines = [line.rstrip() for line in open('script2.py') if line[0] == 'p']
       >>> lines
       ['print(sys.path)', 'print(x ** 32)']
     #+end_src
**** NESTED LOOPS: FOR
     #+begin_src python
       >>> [x + y for x in 'abc' for y in 'lmn']
       ['al', 'am', 'an', 'bl', 'bm', 'bn', 'cl', 'cm', 'cn']
     #+end_src
** Other Iteration Contexts
   #+begin_src python
     >>> uppers = [line.upper() for line in open('script2.py')]
     >>> uppers
     ['IMPORT SYS\n', 'PRINT(SYS.PATH)\n', 'X = 2\n', 'PRINT(X ** 32)\n']

     >>> map(str.upper, open('script2.py'))      # map is itself an iterable in 3.X
     <map object at 0x00000000029476D8>
     >>> list(map(str.upper, open('script2.py')))
     ['IMPORT SYS\n', 'PRINT(SYS.PATH)\n', 'X = 2\n', 'PRINT(X ** 32)\n']
   #+end_src
   
   ~map~ 也是个可迭代对象, 可以生成迭代
*** Multiple Versus Single Pass Iterators

    It’s important to see how the range object differs from the built-ins described in this section—it supports len and indexing, it is not its own iterator (you make one with iter when iterating manually), and it supports multiple iterators over its result that remember their positions independently:

    #+begin_src python
      >>> R = range(3)                           # range allows multiple iterators
      >>> next(R)
      TypeError: range object is not an iterator

      >>> I1 = iter(R)
      >>> next(I1)
      0
      >>> next(I1)
      1
      >>> I2 = iter(R)                           # Two iterators on one range
      >>> next(I2)
      0
      >>> next(I1)                               # I1 is at a different spot than I2
      2
    #+end_src

    ~zip~, ~map~, ~filer~ 不支持多轮迭代, 因为他们的 ~iter~ 就是他们自身:
    #+begin_src python
      In [13]: Z = zip(D, S)

      In [14]: type(Z)
      Out[14]: zip

      In [15]: i = iter(Z)

      In [16]: i is Z
      Out[16]: True

      In [17]: j = iter(Z)

      In [18]: i is j
      Out[18]: True
    #+end_src
*** Dictionary View Iterables
    #+begin_src python
      >>> D = dict(a=1, b=2, c=3)
      >>> D
      {'a': 1, 'b': 2, 'c': 3}

      >>> K = D.keys()                              # A view object in 3.X, not a list
      >>> K
      dict_keys(['a', 'b', 'c'])

      >>> next(K)                                   # Views are not iterators themselves
      TypeError: dict_keys object is not an iterator

      >>> I = iter(K)                               # View iterables have an iterator,
      >>> next(I)                                   # which can be used manually,
      'a'                                           # but does not support len(), index
      >>> next(I)
      'b'

      >>> for k in D.keys(): print(k, end=' ')      # All iteration contexts use auto
      ...
      a b c
    #+end_src
* Chapter 15. The Documentation Interlude
  Table 15-1. Python documentation sources
  | Form                     | Role                                       |
  | # comments               | In-file documentation                      |
  | The dir function         | Lists of attributes available in objects   |
  | Docstrings: ~__doc__~    | In-file documentation attached to objects  |
  | PyDoc: the help function | Interactive help for objects               |
  | PyDoc: HTML reports      | Module documentation in a browser          |
  | Sphinx third-party tool  | Richer documentation for larger projects   |
  | The standard manual set  | Official language and library descriptions |
  | Web resources            | Online tutorials, examples, and so on      |
  | Published books          | Commercially polished reference texts      |

** Docstrings: ~__doc__~

*** USER-DEFINED DOCSTRINGS
    #+begin_src python
      """
      Module documentation
      Words Go Here
      """

      spam = 40

      def square(x):
	  """
	  function documentation
	  can we have your liver then?
	  """
	  return x ** 2          # square

      class Employee:
	  "class documentation"
	  pass

      print(square(4))
      print(square.__doc__)
    #+end_src

    #+begin_src python
      >>> import docstrings
      16

	  function documentation
	  can we have your liver then?

      >>> print(docstrings.__doc__)

      Module documentation
      Words Go Here

      >>> print(docstrings.square.__doc__)

	  function documentation
	  can we have your liver then?

      >>> print(docstrings.Employee.__doc__)
	  class documentation
    #+end_src

*** DOCSTRING STANDARDS AND PRIORITIES
    简单说就是想怎么写就怎么写...

*** BUILT-IN DOCSTRINGS
    #+begin_src python
      >>> import sys
      >>> print(sys.__doc__)
      This module provides access to some objects used or maintained by the
      interpreter and to functions that interact strongly with the interpreter.

      Dynamic objects:

      argv -- command line arguments; argv[0] is the script pathname if known
      path -- module search path; path[0] is the script directory, else ''
      modules -- dictionary of loaded modules
      ...more text omitted...
    #+end_src

    #+begin_src python
      >>> print(sys.getrefcount.__doc__)
      getrefcount(object) -> integer

      Return the reference count of object.  The count returned is generally
      one higher than you might expect, because it includes the (temporary)
      reference as an argument to getrefcount().
    #+end_src

    除了module, functions, classes, methods都有其 ~__doc__~
    
    
*** PyDoc: The help Function
    就是 ~help~

*** PyDoc: HTML Reports
    #+begin_example
       python3.8  linc@pop-os  ~/python  pydoc -b
      Server ready at http://localhost:39025/
      Server commands: [b]rowser, [q]uit
      server>
    #+end_example
* Chapter 16. Function Basics
  Table 16-1. Function-related statements and expressions
  | Statement or expression | Examples                                                                 |
  | Call expressions        | myfunc('spam', 'eggs', meat=ham, *rest)                                  |
  | def                     | def printer(message):     print('Hello ' + message) return               |
  |                         | def adder(a, b=1, *c):     return a + b + c[0]                           |
  | global                  | x = 'old' def changer():     global x; x = 'new'                         |
  | nonlocal (3.X)          | def outer():    x = 'old'    def changer():        nonlocal x; x = 'new' |
  | yield                   | def squares(x):    for i in range(x): yield i ** 2                       |
  | lambda                  | funcs = [lambda x: x**2, lambda x: x**3]                                 |

  By and large, we code to object interfaces in Python, not data types.

  我们为对象的借口编程, 而非对象的数据类型.

** A Second Example: Intersecting Sequences

   
* Chapter 17. Scopes

** Python Scope Basics

   - Names assigned inside a def can only be seen by the code within that def. You cannot even refer to such names from outside the function.

   - Names assigned inside a def do not clash with variables outside the def, even if the same names are used elsewhere. A name X assigned outside a given def (i.e., in a different def or at the top level of a module file) is a completely different variable from a name X assigned inside that def.

   variables may be assigned in three different places, corresponding to three different scopes:

   - If a variable is assigned inside a def, it is local to that function.

   - If a variable is assigned in an enclosing def, it is nonlocal to nested functions.

   - If a variable is assigned outside all defs, it is global to the entire file.

*** Name Resolution: The LEGB Rule
    Within a def statement:

    - Name assignments create or change local names by default.

    - Name references search at most four scopes: local, then enclosing functions (if any), then global, then built-in.

    - Names declared in global and nonlocal statements map assigned names to enclosing module and function scopes, respectively.

    Python’s name-resolution scheme is sometimes called the LEGB rule, after the scope names:

    - When you use an unqualified name inside a function, Python searches up to four scopes—the local (L) scope, then the local scopes of any enclosing (E) defs and lambdas, then the global (G) scope, and then the built-in (B) scope—and stops at the first place the name is found. If the name is not found during this search, Python reports an error.

    - When you assign a name in a function (instead of just referring to it in an expression), Python always creates or changes the name in the local scope, unless it’s declared to be global or nonlocal in that function.

    - When you assign a name outside any function (i.e., at the top level of a module file, or at the interactive prompt), the local scope is the same as the global scope—the module’s namespace.

** The global Statement
** Scopes and Nested Functions
** Why nonlocal? State Retention Options
*** State with nonlocal: 3.X only
    #+begin_src python
      >>> def tester(start):
	      state = start                  # Each call gets its own state
	      def nested(label):
		  nonlocal state             # Remembers state in enclosing scope
		  print(label, state)
		  state += 1                 # Allowed to change it if nonlocal
	      return nested

      >>> F = tester(0)
      >>> F('spam')                          # State visible within closure only
      spam 0
      >>> F.state
      AttributeError: 'function' object has no attribute 'state'
    #+end_src
    
    函数工厂, 生成一个函数, F是一个函数对象(function object), 而 ~stat~ 在不同的函数对象中都有一个副本

*** State with Globals: A Single Copy Only
    
    #+begin_src python
      >>> def tester(start):
	      global state                   # Move it out to the module to change it
	      state = start                  # global allows changes in module scope
	      def nested(label):
		  global state
		  print(label, state)
		  state += 1
	      return nested

      >>> F = tester(0)
      >>> F('spam')                          # Each call increments shared global state
      spam 0
      >>> F('eggs')
      eggs 1
    #+end_src

    #+begin_src python
      >>> G = tester(42)                     # Resets state's single copy in global scope
      >>> G('toast')
      toast 42

      >>> G('bacon')
      bacon 43

      >>> F('ham')                           # But my counter has been overwritten!
      ham 44
    #+end_src

    全局变量, 只有一个对象

*** State with Classes: Explicit Attributes (Preview)
    
    #+begin_src python
      >>> class tester:                          # Class-based alternative (see Part VI)
	      def __init__(self, start):         # On object construction,
		  self.state = start             # save state explicitly in new object
	      def nested(self, label):
		  print(label, self.state)       # Reference state explicitly
		  self.state += 1                # Changes are always allowed

      >>> F = tester(0)                          # Create instance, invoke __init__
      >>> F.nested('spam')                       # F is passed to self
      spam 0
      >>> F.nested('ham')
      ham 1
    #+end_src

    Class -> 指明属性(Attribute)

    
*** State with Function Attributes: 3.X and 2.X

** WHY YOU WILL CARE: CUSTOMIZING OPEN
   #+begin_src python
     import builtins

     def makeopen(id):
	 original = builtins.open
	 def custom(*pargs, **kargs):
	     print('Custom open call %r:' % id , pargs, kargs)
	     return original(*pargs, **kargs)
	 builtins.open = custom
   #+end_src

* Chapter 18. Arguments

** Arguments and Shared References
   
   参数是对象的共享引用, 因此如果该对象mutable, 则可以在函数中进行修改.

   如果想避免对mutable参数的修改, 要么传一个副本进来, 要么在函数中创建一个副本, 对副本进行操作.

   函数如果有多个返回值, 其实是一个tuple, 在caller处进行unpack.

   
** 参数匹配

   Table 18-1. Function argument-matching forms
   | Syntax                  | Location | Interpretation                                                   |
   | func(value)             | Caller   | Normal argument: matched by position                             |
   | func(name=value)        | Caller   | Keyword argument: matched by name                                |
   | func(*iterable)         | Caller   | Pass all objects in iterable as individual positional arguments  |
   | func(**dict)            | Caller   | Pass all key/value pairs in dict as individual keyword arguments |
   | def func(name)          | Function | Normal argument: matches any passed value by position or name    |
   | def func(name=value)    | Function | Default argument value, if not passed in the call                |
   | def func(*name)         | Function | Matches and collects remaining positional arguments in a tuple   |
   | def func(**name)        | Function | Matches and collects remaining keyword arguments in a dictionary |
   | def func(*other, name)  | Function | Arguments that must be passed by keyword only in calls (3.X)     |
   | def func(*, name=value) |          | Arguments that must be passed by keyword only in calls (3.X)     |

   Beware mutable defaults: As footnoted in the prior chapter, if you code a default to be a mutable object (e.g., def f(a=[])), the same, single mutable object is reused every time the function is later called—even if it is changed in place within the function. The net effect is that the argument’s default retains its value from the prior call, and is not reset to its original value coded in the def header. 

   #+begin_src python
     In [4]: def f(a=[]):
	...:     a.append(1);
	...:     print(a)
	...:

     In [5]: f()
     [1]

     In [6]: f()
     [1, 1]

     In [7]: f()
     [1, 1, 1]
   #+end_src

** keyword-only arguments

   keyword-only arguments must be coded before the **args arbitrary keywords form and after the *args arbitrary positional form, when both are present. 
   
   强制keyword参数 *必须* 在 ~**~ 之前, 在 ~*~ 之后.

   #+begin_src python
     >>> def f(a, *b, **d, c=6): print(a, b, c, d)          # Keyword-only before **!
     SyntaxError: invalid syntax

     >>> def f(a, *b, c=6, **d): print(a, b, c, d)          # Collect args in header
   #+end_src

   In fact, similar ordering rules hold true in *function calls*: when keyword-only arguments are passed, they must appear before a **args form. The keyword-only argument can be coded either before or after the *args, though, and may be included in **args:

   调用的时候, keyword-only参数必须在 ~**~ 之前出现, 或者是出现在 ~**~ 中.

*** WHY KEYWORD-ONLY ARGUMENTS?
    
    So why care about keyword-only arguments? In short, they make it easier to allow a function to accept both any number of positional arguments to be processed, and configuration options passed as keywords. While their use is optional, without keyword-only arguments extra work may be required to provide defaults for such options and to verify that no superfluous keywords were passed.
    
    

